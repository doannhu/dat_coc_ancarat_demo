from pydantic import BaseModel, ConfigDict
from typing import Optional, List
from datetime import datetime
from app.db.models import TransactionType

from app.modules.customers.schemas import Customer
from app.modules.stores.schemas import Store
from app.modules.staff.schemas import Staff
from app.modules.products.schemas import Product

class TransactionItemBase(BaseModel):
    product_id: int
    price_at_time: float

class TransactionItemCreate(TransactionItemBase):
    pass

class TransactionItem(TransactionItemBase):
    id: int
    transaction_id: int
    product: Optional[Product] = None
    swapped: bool = False
    original_product_id: Optional[int] = None
    original_product: Optional[Product] = None
    model_config = ConfigDict(from_attributes=True)

class TransactionBase(BaseModel):
    type: str
    customer_id: Optional[int] = None
    staff_id: int
    store_id: int
    linked_transaction_id: Optional[int] = None

class TransactionCreate(TransactionBase):
    # This is slightly simplified. For complex operations like 'create_order', 
    # the input might need to be richer (e.g. list of product types and quantities, not just IDs).
    # We might need specific schemas for specific operations (e.g. OrderCreate, BuybackCreate)
    # But for raw CRUD, this is fine.
    pass

class OrderCreateItem(BaseModel):
    product_type: str
    quantity: int
    price: float
    is_new: bool = True
    product_id: Optional[int] = None  # For selecting specific available product

class OrderCreate(BaseModel):
    staff_id: int
    customer_id: int
    store_id: int
    items: List[OrderCreateItem]
    created_at: Optional[datetime] = None
    payment_method: Optional[str] = "cash"
    cash_amount: Optional[float] = 0.0
    bank_transfer_amount: Optional[float] = 0.0

class ManufacturerOrderItem(BaseModel):
    product_id: Optional[int] = None # For existing
    product_type: Optional[str] = None # For new
    quantity: int = 1
    manufacturer_price: float

class ManufacturerOrderCreate(BaseModel):
    code: str # Manual manufacturer code
    transaction_code: Optional[str] = None # System auto-generated code (optional in input, generated by backend)
    created_at: Optional[datetime] = None
    staff_id: int
    store_id: int
    items: List[ManufacturerOrderItem]

class OrderUpdate(BaseModel):
    customer_id: Optional[int] = None
    store_id: Optional[int] = None
    staff_id: Optional[int] = None
    created_at: Optional[datetime] = None
    payment_method: Optional[str] = None
    cash_amount: Optional[float] = None
    bank_transfer_amount: Optional[float] = None
    transaction_code: Optional[str] = None

class ManufacturerOrderUpdate(BaseModel):
    code: Optional[str] = None
    store_id: Optional[int] = None
    staff_id: Optional[int] = None
    created_at: Optional[datetime] = None
    transaction_code: Optional[str] = None

class TransactionInDBBase(TransactionBase):
    id: int
    created_at: datetime
    model_config = ConfigDict(from_attributes=True)

class Transaction(TransactionInDBBase):
    items: List[TransactionItem] = []
    customer: Optional[Customer] = None
    store: Optional[Store] = None
    staff: Optional[Staff] = None
    order_status: Optional[str] = None  # Derived field: 'buyback', 'fulfilled', or None
    code: Optional[str] = None  # Manufacturer order code (manual)
    transaction_code: Optional[str] = None  # Transaction code (auto-generated)
    payment_method: Optional[str] = None
    cash_amount: float = 0.0
    bank_transfer_amount: float = 0.0

from typing import Dict

class StoreStats(BaseModel):
    store_name: str
    total_orders: int
    revenue: float

class TransactionStats(BaseModel):
    total_orders: int
    total_revenue: float
    payment_method_stats: Dict[str, float]
    store_stats: List[StoreStats]

# Buyback schemas
class BuybackItem(BaseModel):
    product_id: int
    buyback_price: float

class BuybackCreate(BaseModel):
    original_transaction_id: int  # The sale transaction being bought back
    staff_id: int
    store_id: int
    items: List[BuybackItem]
    created_at: Optional[datetime] = None
    payment_method: Optional[str] = "cash"

# Fulfillment schemas
class FulfillmentItem(BaseModel):
    product_id: int

class FulfillmentCreate(BaseModel):
    original_transaction_id: int  # The sale transaction being fulfilled
    staff_id: int
    store_id: int
    items: List[FulfillmentItem]  # Products being delivered to customer
    created_at: Optional[datetime] = None

# Sell-back to manufacturer schemas
class SellBackItem(BaseModel):
    product_id: int
    sell_back_price: float

class SellBackCreate(BaseModel):
    original_transaction_id: int  # The manufacturer order being sold back
    staff_id: int
    store_id: int
    items: List[SellBackItem]
    created_at: Optional[datetime] = None

# Receive from manufacturer schemas
class ManufacturerReceiveItem(BaseModel):
    product_id: int
    # Price is optionally updated, usually it's the cost price
    price: Optional[float] = None 

class ManufacturerReceiveCreate(BaseModel):
    original_transaction_id: int # The manufacturer order
    staff_id: int
    store_id: int
    items: List[ManufacturerReceiveItem]
    created_at: Optional[datetime] = None

# Swap schemas
class SwapCreate(BaseModel):
    product_ids_1: List[int]
    product_ids_2: List[int]
    staff_id: int
    store_id: int
    note: Optional[str] = None
    created_at: Optional[datetime] = None

class FinancialStats(BaseModel):
    money_in: float
    money_in_breakdown: Dict[str, float]
    money_out: float
    money_out_breakdown: Dict[str, float]
